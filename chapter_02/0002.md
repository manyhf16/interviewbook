---
search:
    keywords: ['事务', '隔离级别']

---


# 简述ORACLE数据库事务隔离级别

事务隔离级别是指：两个事务之间的数据可见度

数据库为了提高效率，允许多个事务同时修改数据，这就带来了相应的问题：事务1修改的数据，对于事务2而言是否可见？

SQL规范中对于事务的隔离性提供了四个级别：

|隔离级别|效果|说明|
|-|-|-|
|未提交读|事务1会读取到事务2未提交的数据|这是最低的一种隔离级别，会有脏数据发生：例如，事务2插入一条记录，事务1读取到了，然后事务2又做了回滚|
|提交读|事务1会读到事务2提交之后的数据|这是oracle默认的隔离级别，能够避免脏读|

事务隔离级别：一个事务对数据库的修改与并行的另一个事务的隔离程度。
 
两个并发事务同时访问数据库表相同的行时，可能存在以下三个问题：
 
1、幻想读：事务T1读取一条指定where条件的语句，返回结果集。此时事务T2插入一行新记录，恰好满足T1的where条件。然后T1使用相同的条件再次查询，结果集中可以看到T2插入的记录，这条新纪录就是幻想。
 
2、不可重复读取：事务T1读取一行记录，紧接着事务T2修改了T1刚刚读取的记录，然后T1再次查询，发现与第一次读取的记录不同，这称为不可重复读。
 
3、脏读：事务T1更新了一行记录，还未提交所做的修改，这个T2读取了更新后的数据，然后T1执行回滚操作，取消刚才的修改，所以T2所读取的行就无效，也就是脏数据。
 
为了处理这些问题，SQL标准定义了以下几种事务隔离级别
 
READ UNCOMMITTED 幻想读、不可重复读和脏读都允许。
 
READ COMMITTED 允许幻想读、不可重复读，不允许脏读
 
REPEATABLE READ 允许幻想读，不允许不可重复读和脏读
 
SERIALIZABLE 幻想读、不可重复读和脏读都不允许
 
Oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。所以Oracle不支持脏读
 
SQL标准所定义的默认事务隔离级别是SERIALIZABLE，但是Oracle 默认使用的是READ COMMITTED。





 



