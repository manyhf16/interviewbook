---
search:
    keywords: ['sql', '优化']

---


# oracle中的sql如何优化，有哪些方式？

# 参考解答

## 1. WHERE子句中的条件出现顺序
oracle处理where条件时，从右向左进行解析，因此，那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾。
例如: 
```sql
SELECT … FROM EMP E WHERE 
    NAME LIKE 'S%' AND JOB = 'MANAGER'; 
```
将比下列SQL更有效率 
```sql
SELECT … FROM EMP E WHERE 
    JOB = 'MANAGER' AND NAME LIKE 'S%'; 
```

## 2. SELECT子句中避免使用 *
ORACLE在解析的过程中, 会将 * 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间。

## 3. 充分使用共享池和预编译sql，减少sql的硬解析次数。

例如：
```sql
variable id number;
exec :id := 1;
select id, name from t_product where id = :id;
exec :id := 2;
select id, name from t_product where id = :id;
```
效率要高于：
```sql
select id, name from t_product where id = 1;
select id, name from t_product where id = 2;
```
后面的sql需要执行两次硬解析，而之前用变量占位的sql只需要硬解析一次。
> **注意** 
java中可以利用PreparedStatement来达到相同的效果

## 4. 先过滤再分组
低效: 
```sql
SELECT JOB, AVG(SAL) FROM EMP 
  GROUP BY JOB HAVING JOB = 'PRESIDENT' OR JOB = 'MANAGER';
```
高效: 
```
SELECT JOB, AVG(SAL) FROM EMP 
  WHERE JOB = 'PRESIDENT' OR JOB = 'MANAGER' GROUP BY JOB;
```

## 5. 最高效的删除重复记录方法 (使用ROWID)
例，删除EMPNO相同的员工：
```sql
DELETE FROM EMP E WHERE  
    E.ROWID > (SELECT MIN(X.ROWID) FROM EMP X WHERE X.EMPNO = E.EMPNO);
      
```
## 6. 全表数据删除用TRUNCATE替代DELETE
truncate 不受事务影响，不需要使用回滚段，如果确定删除操作不必恢复，可以使用truncate 提高效率
 
## 7. 让事务尽可能短 
事务结束会释放的资源：
a. 回滚段上用于恢复数据的信息
b. 增删改查数据时用到的锁 
c. redo，log，buffer中的空间 
d. ORACLE为管理上述3种资源中的内部花费

## 8. 用EXISTS替代IN、用NOT EXISTS替代NOT IN
在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接。在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率。在子查询中,NOT IN子句将执行一个内部的排序和合并。 无论在哪种情况下,NOT IN都是最低效的 (因为它对子查询中的表执行了一个全表遍历)。为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或NOT EXISTS。
例子：（高效）
```
SELECT * FROM  EMP (基础表)  WHERE  
    EMPNO > 0  
    AND  EXISTS (SELECT 'X'  FROM DEPT  WHERE  DEPT.DEPTNO    
    = EMP.DEPTNO  AND  LOC = 'MELB')
```
(低效)
```
SELECT  * FROM  EMP (基础表)  WHERE  
    EMPNO > 0  
    AND  DEPTNO IN(SELECT DEPTNO  FROM  DEPT  WHERE  LOC =    
    'MELB')
```
## 9. 识别“慢查询”
可以利用Druid这样带“监测”功能的数据源查看每条sql的执行时间，找到那些执行时间长的查询sql进行优化

（17）用索引提高效率：
索引是表的一个概念部分,用来提高检索数据的效率，ORACLE使用了一个复杂的自平衡B-tree结构。通常,通过索引查询数据比全表扫描要快。当ORACLE找出执行查询和Update语句的最佳路径时, ORACLE优化器将使用索引。 同样在联结多个表时使用索引也可以提高效率. 另一个使用索引的好处是,它提供了主键(primary key)的唯一性验证。那些LONG或LONG RAW数据类型, 你可以索引几乎所有的列。 通常, 在大型表中使用索引特别有效。 当然,你也会发现, 在扫描小表时,使用索引同样能提高效率。 虽然使用索引能得到查询效率的提高,但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改。 这意味着每条记录的INSERT , DELETE , UPDATE将为此多付出4 , 5 次的磁盘I/O 。 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢。定期的重构索引是有必要的。
（18） 用EXISTS替换DISTINCT：
当提交一个包含一对多表信息(比如部门表和雇员表)的查询时,避免在SELECT子句中使用DISTINCT。一般可以考虑用EXIST替换, EXISTS 使查询更为迅速,因为RDBMS核心模块将在子查询的条件一旦满足后,立刻返回结果。 
例子：(低效)
```
SELECT  DISTINCT  DEPT_NO,DEPT_NAME  FROM  DEPT D , EMP E 
    WHERE  D.DEPT_NO = E.DEPT_NO;
```
(高效)
```
SELECT  DEPT_NO,DEPT_NAME  FROM  DEPT D  WHERE  
    EXISTS ( SELECT 'X' FROM  EMP E  WHERE E.DEPT_NO =  D.DEPT_NO);
```
（19）sql语句用大写的；因为oracle总是先解析sql语句，把小写的字母转换成大写的再执行。

（21）避免在索引列上使用NOT通常，我们要避免在索引列上使用NOT, NOT会产生在和在索引列上使用函数相同的影响。当ORACLE“遇到”NOT,他就会停止使用索引转而执行全表扫描。
（22）避免在索引列上使用计算。
WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描。 
举例: 低效
```
SELECT … FROM  DEPT  WHERE SAL * 12 > 25000; 
```
高效
```
SELECT … FROM DEPT WHERE SAL > 25000/12;
```
（23）用 >= 替代 >
高效
```
SELECT * FROM  EMP  WHERE  DEPTNO >=4 
```
低效
```
SELECT * FROM EMP WHERE DEPTNO >3 
```
两者的区别在于, 前者DBMS将直接跳到第一个DEPT等于4的记录而后者将首先定位到DEPTNO=3的记录并且向前扫描到第一个DEPT大于3的记录。
（24）用UNION替换OR(适用于索引列)
通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果。对索引列使用OR将造成全表扫描。注意, 以上规则只针对多个索引列有效。如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低。 在下面的例子中, LOC_ID 和REGION上都建有索引。
高效: 
```
SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE      
    LOC_ID = 10 
UNION 
SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE  
    REGION = 'MELBOURNE'
```
低效: 
```
SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE  
    LOC_ID = 10 OR REGION = 'MELBOURNE' 
```
如果你坚持要用OR, 那就需要返回记录最少的索引列写在最前面。
（25）用IN来替换OR  
这是一条简单易记的规则，但是实际的执行效果还须检验，在ORACLE8i下，两者的执行路径似乎是相同的。
低效: 
```
SELECT…. FROM LOCATION WHERE 
    LOC_ID = 10 
    OR LOC_ID = 20 
    OR LOC_ID = 30 
```
高效 
```
SELECT… FROM LOCATION WHERE LOC_IN  IN (10,20,30);
```
（26）索引列不要有NULL值
建立索引时NULL值行不会被加入索引，因此就无法利用索引的优势，因此如果这一列需要经常查询并建立索引，这一列最好加上非空约束保证没有NULL值。

（27）多列索引时，总是要使用索引的第一个列：
如果索引是建立在多个列上, 只有在它的第一个列(leading column)被where子句引用时,优化器才会选择使用该索引。 这也是一条简单而重要的规则，当仅引用索引的第二个列时,优化器使用了全表扫描而忽略了索引。

（28） 用UNION-ALL 替换UNION ( 如果有可能的话)：
当SQL语句需要UNION两个查询结果集合时,这两个结果集合会以UNION-ALL的方式被合并, 然后在输出最终结果前进行排序。 如果用UNION ALL替代UNION, 这样排序就不是必要了。 效率就会因此得到提高。 需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录。 因此各位还是要从业务需求分析使用UNION ALL的可行性。UNION 将对结果集合排序,这个操作会使用到SORT_AREA_SIZE这块内存。 对于这块内存的优化也是相当重要的。 下面的SQL可以用来查询排序的消耗量。
低效： 
```
SELECT  ACCT_NUM, BALANCE_AMT FROM  DEBIT_TRANSACTIONS 
    WHERE TRAN_DATE = '31-DEC-95' 
UNION 
SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS 
    WHERE TRAN_DATE = '31-DEC-95' 
```
高效: 
```
SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS 
    WHERE TRAN_DATE = '31-DEC-95' 
UNION ALL 
SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS 
    WHERE TRAN_DATE = '31-DEC-95'
```
（29）用WHERE替代ORDER BY：
ORDER BY 子句只在两种严格的条件下使用索引。
ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序。
ORDER BY中所有的列必须定义为非空。 
WHERE子句使用的索引和ORDER BY子句中所使用的索引不能并列。
例如: 表DEPT包含以下列: 
DEPT_CODE PK NOT NULL 
DEPT_DESC NOT NULL 
DEPT_TYPE NULL
低效: (索引不被使用) 
```
SELECT DEPT_CODE FROM  DEPT  ORDER BY  DEPT_TYPE; 
```
高效: (使用索引) 
```
SELECT DEPT_CODE  FROM  DEPT  WHERE  DEPT_TYPE > 0
```
（30）避免改变索引列的类型
当比较不同数据类型的数据时, ORACLE自动对列进行简单的类型转换 。
假设 EMPNO是一个数值类型的索引列。
```
SELECT …  FROM EMP  WHERE  EMPNO = '123' 
```
实际上,经过ORACLE类型转换, 语句转化为: 
```
SELECT …  FROM EMP  WHERE  EMPNO = TO_NUMBER('123') 
```
幸运的是,类型转换没有发生在索引列上,索引的用途没有被改变。
现在,假设EMP_TYPE是一个字符类型的索引列。 
```
SELECT …  FROM EMP  WHERE EMP_TYPE = 123 
```
这个语句被ORACLE转换为: 
```
SELECT …  FROM EMP  WHERE TO_NUMBER(EMP_TYPE)=123 
```
因为内部发生的类型转换, 这个索引将不会被用到。 为了避免ORACLE对你的SQL进行隐式的类型转换, 最好把类型转换用显式表现出来。 注意当字符和数值比较时, ORACLE会优先转换数值类型到字符类型。
（31）需要当心的WHERE子句:
某些SELECT 语句中的WHERE子句不使用索引。 这里有一些例子。
在下面的例子里, (1)'!=' 将不使用索引。 记住, 索引只能告诉你什么存在于表中, 而不能告诉你什么不存在于表中。 (2) '||'是字符连接函数。 就象其他函数那样, 停用了索引。 (3) '+'是数学函数。就象其他数学函数那样, 停用了索引。 (4)相同的索引列不能互相比较,这将会启用全表扫描。
（32）
a如果检索数据量超过30%的表中记录数。使用索引将没有显著的效率提高。 
b在特定情况下, 使用索引也许会比全表扫描慢, 但这是同一个数量级上的区别. 而通常情况下,使用索引比全表扫描要块几倍乃至几千倍!
（33）避免使用耗费资源的操作:
带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎执行耗费资源的排序(SORT)功能。 DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序。 通常, 带有UNION, MINUS , INTERSECT的SQL语句都可以用其他方式重写。 如果你的数据库的SORT_AREA_SIZE调配得好, 使用UNION , MINUS, INTERSECT也是可以考虑的, 毕竟它们的可读性很强。
 



